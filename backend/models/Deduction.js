const oracledb = require('oracledb');
const { getConnection } = require('../config/database');

class Deduction {
  static async createTable() {
    let connection;
    try {
      connection = await getConnection();
      
      const createTableSQL = `
        CREATE TABLE HRMS_DEDUCTIONS (
          DEDUCTION_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1) PRIMARY KEY,
          EMPLOYEE_ID NUMBER NOT NULL,
          DEDUCTION_TYPE VARCHAR2(50) NOT NULL CHECK (DEDUCTION_TYPE IN ('FINE', 'PENALTY', 'SALARY_ADVANCE_RECOVERY', 'LOAN_RECOVERY', 'MISCELLANEOUS', 'DISCIPLINARY', 'ATTENDANCE', 'OTHER')),
          DEDUCTION_CATEGORY VARCHAR2(50) NOT NULL CHECK (DEDUCTION_CATEGORY IN ('STATUTORY', 'VOLUNTARY', 'RECOVERY', 'PENALTY')),
          AMOUNT NUMBER(15,2) NOT NULL CHECK (AMOUNT > 0),
          REASON VARCHAR2(1000) NOT NULL,
          DEDUCTION_DATE DATE DEFAULT SYSDATE NOT NULL,
          EFFECTIVE_FROM_MONTH VARCHAR2(7) NOT NULL,
          EFFECTIVE_TO_MONTH VARCHAR2(7),
          STATUS VARCHAR2(20) DEFAULT 'ACTIVE' CHECK (STATUS IN ('ACTIVE', 'COMPLETED', 'CANCELLED', 'PENDING')),
          IS_RECURRING CHAR(1) DEFAULT 'N' CHECK (IS_RECURRING IN ('Y', 'N')),
          RECURRING_MONTHS NUMBER,
          DEDUCTED_AMOUNT NUMBER(15,2) DEFAULT 0,
          REMAINING_AMOUNT NUMBER(15,2),
          ATTACHMENT_URL VARCHAR2(500),
          APPLIED_BY NUMBER NOT NULL,
          APPROVED_BY NUMBER,
          APPROVED_DATE DATE,
          COMMENTS CLOB,
          CREATED_AT DATE DEFAULT SYSDATE,
          UPDATED_AT DATE DEFAULT SYSDATE,
          CONSTRAINT FK_DEDUCTION_EMPLOYEE FOREIGN KEY (EMPLOYEE_ID) REFERENCES HRMS_EMPLOYEES(EMPLOYEE_ID),
          CONSTRAINT FK_DEDUCTION_APPLIED_BY FOREIGN KEY (APPLIED_BY) REFERENCES HRMS_USERS(USER_ID),
          CONSTRAINT FK_DEDUCTION_APPROVED_BY FOREIGN KEY (APPROVED_BY) REFERENCES HRMS_USERS(USER_ID)
        )
      `;

      await connection.execute(createTableSQL);

      // Create indexes for better performance
      const createIndexes = [
        `CREATE INDEX IDX_DEDUCTIONS_EMPLOYEE ON HRMS_DEDUCTIONS (EMPLOYEE_ID)`,
        `CREATE INDEX IDX_DEDUCTIONS_TYPE ON HRMS_DEDUCTIONS (DEDUCTION_TYPE)`,
        `CREATE INDEX IDX_DEDUCTIONS_STATUS ON HRMS_DEDUCTIONS (STATUS)`,
        `CREATE INDEX IDX_DEDUCTIONS_DATE ON HRMS_DEDUCTIONS (DEDUCTION_DATE)`,
        `CREATE INDEX IDX_DEDUCTIONS_EFFECTIVE_FROM ON HRMS_DEDUCTIONS (EFFECTIVE_FROM_MONTH)`
      ];

      for (const indexSQL of createIndexes) {
        try {
          await connection.execute(indexSQL);
        } catch (error) {
          if (!error.message.includes('ORA-00955')) { // Index already exists
            console.warn('Warning creating index:', error.message);
          }
        }
      }

      // Create trigger for updating UPDATED_AT
      const triggerSQL = `
        CREATE OR REPLACE TRIGGER TRG_DEDUCTIONS_UPDATED_AT
        BEFORE UPDATE ON HRMS_DEDUCTIONS
        FOR EACH ROW
        BEGIN
          :NEW.UPDATED_AT := SYSDATE;
          -- Update remaining amount when deducted amount changes
          IF :NEW.DEDUCTED_AMOUNT != :OLD.DEDUCTED_AMOUNT THEN
            :NEW.REMAINING_AMOUNT := :NEW.AMOUNT - :NEW.DEDUCTED_AMOUNT;
          END IF;
          -- Auto-complete when fully deducted
          IF :NEW.REMAINING_AMOUNT <= 0 AND :OLD.STATUS = 'ACTIVE' THEN
            :NEW.STATUS := 'COMPLETED';
          END IF;
        END;
      `;

      await connection.execute(triggerSQL);

      console.log('✅ HRMS_DEDUCTIONS table created successfully with indexes and triggers');
      
    } catch (error) {
      if (error.errorNum === 955) {
        console.log('ℹ️ HRMS_DEDUCTIONS table already exists');
      } else {
        console.error('❌ Error creating HRMS_DEDUCTIONS table:', error);
        throw error;
      }
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (error) {
          console.error('Error closing connection:', error);
        }
      }
    }
  }

  static async create(deductionData) {
    let connection;
    try {
      connection = await getConnection();
      
      const {
        employeeId,
        deductionType,
        deductionCategory,
        amount,
        reason,
        deductionDate,
        effectiveFromMonth,
        effectiveToMonth,
        isRecurring,
        recurringMonths,
        attachmentUrl,
        appliedBy,
        comments
      } = deductionData;

      // Calculate remaining amount (initially equals total amount)
      const remainingAmount = amount;

      const insertSQL = `
        INSERT INTO HRMS_DEDUCTIONS (
          EMPLOYEE_ID, DEDUCTION_TYPE, DEDUCTION_CATEGORY, AMOUNT, REASON,
          DEDUCTION_DATE, EFFECTIVE_FROM_MONTH, EFFECTIVE_TO_MONTH,
          IS_RECURRING, RECURRING_MONTHS, REMAINING_AMOUNT,
          ATTACHMENT_URL, APPLIED_BY, COMMENTS
        ) VALUES (
          :employeeId, :deductionType, :deductionCategory, :amount, :reason,
          TO_DATE(:deductionDate, 'YYYY-MM-DD'), :effectiveFromMonth, :effectiveToMonth,
          :isRecurring, :recurringMonths, :remainingAmount,
          :attachmentUrl, :appliedBy, :comments
        ) RETURNING DEDUCTION_ID INTO :deductionId
      `;

      const binds = {
        employeeId,
        deductionType,
        deductionCategory,
        amount,
        reason,
        deductionDate,
        effectiveFromMonth,
        effectiveToMonth,
        isRecurring: isRecurring || 'N',
        recurringMonths,
        remainingAmount,
        attachmentUrl,
        appliedBy,
        comments,
        deductionId: { type: oracledb.NUMBER, dir: oracledb.BIND_OUT }
      };

      const result = await connection.execute(insertSQL, binds, { autoCommit: true });
      
      const deductionId = result.outBinds.deductionId[0];
      
      return {
        success: true,
        deductionId: deductionId,
        message: 'Deduction created successfully'
      };
      
    } catch (error) {
      console.error('Error creating deduction:', error);
      throw error;
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (error) {
          console.error('Error closing connection:', error);
        }
      }
    }
  }

  static async findById(deductionId) {
    let connection;
    try {
      connection = await getConnection();
      
      const selectSQL = `
        SELECT 
          d.*,
          e.EMPLOYEE_CODE,
          e.FIRST_NAME as EMPLOYEE_FIRST_NAME,
          e.LAST_NAME as EMPLOYEE_LAST_NAME,
          e.EMAIL as EMPLOYEE_EMAIL,
          u1.USERNAME as APPLIED_BY_USERNAME,
          u1.FIRST_NAME as APPLIED_BY_FIRST_NAME,
          u1.LAST_NAME as APPLIED_BY_LAST_NAME,
          u2.USERNAME as APPROVED_BY_USERNAME,
          u2.FIRST_NAME as APPROVED_BY_FIRST_NAME,
          u2.LAST_NAME as APPROVED_BY_LAST_NAME
        FROM HRMS_DEDUCTIONS d
        LEFT JOIN HRMS_EMPLOYEES e ON d.EMPLOYEE_ID = e.EMPLOYEE_ID
        LEFT JOIN HRMS_USERS u1 ON d.APPLIED_BY = u1.USER_ID
        LEFT JOIN HRMS_USERS u2 ON d.APPROVED_BY = u2.USER_ID
        WHERE d.DEDUCTION_ID = :deductionId
      `;

      const result = await connection.execute(selectSQL, { deductionId }, {
        outFormat: oracledb.OUT_FORMAT_OBJECT
      });
      
      let data = result.rows[0] || null;
      
      // Process CLOB fields if present
      if (data && data.COMMENTS && typeof data.COMMENTS === 'object') {
        data.COMMENTS = await data.COMMENTS.getData();
      }
      
      return {
        success: true,
        data: data
      };
      
    } catch (error) {
      console.error('Error finding deduction by ID:', error);
      throw error;
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (error) {
          console.error('Error closing connection:', error);
        }
      }
    }
  }

  static async update(deductionId, updateData) {
    let connection;
    try {
      connection = await getConnection();
      
      const {
        deductionType,
        deductionCategory,
        amount,
        reason,
        deductionDate,
        effectiveFromMonth,
        effectiveToMonth,
        isRecurring,
        recurringMonths,
        attachmentUrl,
        comments,
        status
      } = updateData;

      const updateSQL = `
        UPDATE HRMS_DEDUCTIONS SET
          DEDUCTION_TYPE = :deductionType,
          DEDUCTION_CATEGORY = :deductionCategory,
          AMOUNT = :amount,
          REASON = :reason,
          DEDUCTION_DATE = TO_DATE(:deductionDate, 'YYYY-MM-DD'),
          EFFECTIVE_FROM_MONTH = :effectiveFromMonth,
          EFFECTIVE_TO_MONTH = :effectiveToMonth,
          IS_RECURRING = :isRecurring,
          RECURRING_MONTHS = :recurringMonths,
          ATTACHMENT_URL = :attachmentUrl,
          COMMENTS = :comments,
          STATUS = :status,
          REMAINING_AMOUNT = :amount - DEDUCTED_AMOUNT
        WHERE DEDUCTION_ID = :deductionId
      `;

      const binds = {
        deductionId,
        deductionType,
        deductionCategory,
        amount,
        reason,
        deductionDate,
        effectiveFromMonth,
        effectiveToMonth,
        isRecurring: isRecurring || 'N',
        recurringMonths,
        attachmentUrl,
        comments,
        status: status || 'ACTIVE'
      };

      const result = await connection.execute(updateSQL, binds, { autoCommit: true });
      
      return {
        success: true,
        rowsAffected: result.rowsAffected,
        message: 'Deduction updated successfully'
      };
      
    } catch (error) {
      console.error('Error updating deduction:', error);
      throw error;
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (error) {
          console.error('Error closing connection:', error);
        }
      }
    }
  }

  static async delete(deductionId) {
    let connection;
    try {
      connection = await getConnection();
      
      const deleteSQL = `DELETE FROM HRMS_DEDUCTIONS WHERE DEDUCTION_ID = :deductionId`;
      const result = await connection.execute(deleteSQL, { deductionId }, { autoCommit: true });
      
      return {
        success: true,
        rowsAffected: result.rowsAffected,
        message: 'Deduction deleted successfully'
      };
      
    } catch (error) {
      console.error('Error deleting deduction:', error);
      throw error;
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (error) {
          console.error('Error closing connection:', error);
        }
      }
    }
  }

  static async getAll(filters = {}) {
    let connection;
    try {
      connection = await getConnection();
      
      const {
        page = 1,
        limit = 10,
        search,
        deductionType,
        deductionCategory,
        status,
        employeeId,
        effectiveMonth
      } = filters;

      const offset = (page - 1) * limit;
      
      let whereClause = 'WHERE 1 = 1';
      const binds = {};

      if (search) {
        whereClause += ` AND (
          UPPER(e.FIRST_NAME || ' ' || e.LAST_NAME) LIKE UPPER('%' || :search || '%') OR
          UPPER(e.EMPLOYEE_CODE) LIKE UPPER('%' || :search || '%') OR
          UPPER(d.REASON) LIKE UPPER('%' || :search || '%')
        )`;
        binds.search = search;
      }

      if (deductionType) {
        whereClause += ' AND d.DEDUCTION_TYPE = :deductionType';
        binds.deductionType = deductionType;
      }

      if (deductionCategory) {
        whereClause += ' AND d.DEDUCTION_CATEGORY = :deductionCategory';
        binds.deductionCategory = deductionCategory;
      }

      if (status) {
        whereClause += ' AND d.STATUS = :status';
        binds.status = status;
      }

      if (employeeId) {
        whereClause += ' AND d.EMPLOYEE_ID = :employeeId';
        binds.employeeId = employeeId;
      }

      if (effectiveMonth) {
        whereClause += ' AND d.EFFECTIVE_FROM_MONTH <= :effectiveMonth AND (d.EFFECTIVE_TO_MONTH IS NULL OR d.EFFECTIVE_TO_MONTH >= :effectiveMonth)';
        binds.effectiveMonth = effectiveMonth;
      }

      // Count query
      const countSQL = `
        SELECT COUNT(*) as TOTAL_COUNT
        FROM HRMS_DEDUCTIONS d
        LEFT JOIN HRMS_EMPLOYEES e ON d.EMPLOYEE_ID = e.EMPLOYEE_ID
        ${whereClause}
      `;

      const countResult = await connection.execute(countSQL, binds, {
        outFormat: oracledb.OUT_FORMAT_OBJECT
      });
      const totalItems = countResult.rows[0].TOTAL_COUNT;

      // Data query with proper column aliases
      const selectSQL = `
        SELECT * FROM (
          SELECT 
            d.DEDUCTION_ID,
            d.EMPLOYEE_ID,
            d.DEDUCTION_TYPE,
            d.DEDUCTION_CATEGORY,
            d.AMOUNT,
            d.REASON,
            d.DEDUCTION_DATE,
            d.EFFECTIVE_FROM_MONTH,
            d.EFFECTIVE_TO_MONTH,
            d.STATUS,
            d.IS_RECURRING,
            d.RECURRING_MONTHS,
            d.DEDUCTED_AMOUNT,
            d.REMAINING_AMOUNT,
            d.ATTACHMENT_URL,
            d.APPLIED_BY,
            d.APPROVED_BY,
            d.APPROVED_DATE,
            d.COMMENTS,
            d.CREATED_AT,
            d.UPDATED_AT,
            e.EMPLOYEE_CODE,
            e.FIRST_NAME as EMPLOYEE_FIRST_NAME,
            e.LAST_NAME as EMPLOYEE_LAST_NAME,
            u1.FIRST_NAME as APPLIED_BY_FIRST_NAME,
            u1.LAST_NAME as APPLIED_BY_LAST_NAME,
            u2.FIRST_NAME as APPROVED_BY_FIRST_NAME,
            u2.LAST_NAME as APPROVED_BY_LAST_NAME,
            ROW_NUMBER() OVER (ORDER BY d.CREATED_AT DESC) as RN
          FROM HRMS_DEDUCTIONS d
          LEFT JOIN HRMS_EMPLOYEES e ON d.EMPLOYEE_ID = e.EMPLOYEE_ID
          LEFT JOIN HRMS_USERS u1 ON d.APPLIED_BY = u1.USER_ID
          LEFT JOIN HRMS_USERS u2 ON d.APPROVED_BY = u2.USER_ID
          ${whereClause}
        ) WHERE RN > :offset AND RN <= :limit
      `;

      binds.offset = offset;
      binds.limit = offset + limit;

      const result = await connection.execute(selectSQL, binds, {
        outFormat: oracledb.OUT_FORMAT_OBJECT // Return as objects instead of arrays
      });
      
      // Process CLOB fields to strings
      const processedData = await Promise.all(result.rows.map(async (row) => {
        // REASON is now VARCHAR2, no processing needed
        if (row.COMMENTS && typeof row.COMMENTS === 'object') {
          row.COMMENTS = await row.COMMENTS.getData();
        }
        return row;
      }));
      
      return {
        success: true,
        data: processedData,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(totalItems / limit),
          totalItems: parseInt(totalItems),
          itemsPerPage: parseInt(limit)
        }
      };
      
    } catch (error) {
      console.error('Error getting deductions:', error);
      throw error;
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (error) {
          console.error('Error closing connection:', error);
        }
      }
    }
  }

  static async updateStatus(deductionId, statusData) {
    let connection;
    try {
      connection = await getConnection();
      
      const { status, approvedBy, comments } = statusData;

      const updateSQL = `
        UPDATE HRMS_DEDUCTIONS SET
          STATUS = :status,
          APPROVED_BY = :approvedBy,
          APPROVED_DATE = SYSDATE,
          COMMENTS = :comments
        WHERE DEDUCTION_ID = :deductionId
      `;

      const binds = {
        deductionId,
        status,
        approvedBy,
        comments
      };

      const result = await connection.execute(updateSQL, binds, { autoCommit: true });
      
      return {
        success: true,
        rowsAffected: result.rowsAffected,
        message: `Deduction ${status.toLowerCase()} successfully`
      };
      
    } catch (error) {
      console.error('Error updating deduction status:', error);
      throw error;
    } finally {
      if (connection) {
        try {
          await connection.close();
        } catch (error) {
          console.error('Error closing connection:', error);
        }
      }
    }
  }
}

module.exports = Deduction; 